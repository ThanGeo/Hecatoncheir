<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hecatoncheir: Shape Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hecatoncheir
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">code documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structShape-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Shape Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A spatial object. Could be point, linestring, box or polygon, as specified by its 'dataType' field.  
 <a href="structShape.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="include_2containers_8h_source.html">containers.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Shape:</div>
<div class="dyncontent">
<div class="center"><img src="structShape__coll__graph.png" border="0" usemap="#aShape_coll__map" alt="Collaboration graph"/></div>
<map name="aShape_coll__map" id="aShape_coll__map">
<area shape="rect" title="A spatial object. Could be point, linestring, box or polygon, as specified by its &#39;dataType&#39; field." alt="" coords="63,359,221,597"/>
<area shape="rect" href="structAprilData.html" title="Holds all the APRIL related metadata for a single object." alt="" coords="5,175,172,296"/>
<area shape="rect" href="structMBR.html" title="Struct for Minimum Bounding Rectangles (MBR)." alt="" coords="197,197,274,274"/>
<area shape="rect" href="structPoint.html" title="Struct for 2&#45;dimension points with double coordinates x and y (lon, lat)." alt="" coords="195,5,275,97"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa8d87171e65e0d8ba3c5459978992a7"><td class="memItemLeft" align="right" valign="top"><a id="aaa8d87171e65e0d8ba3c5459978992a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#aaa8d87171e65e0d8ba3c5459978992a7">Shape</a> ()</td></tr>
<tr class="memdesc:aaa8d87171e65e0d8ba3c5459978992a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default empty <a class="el" href="structShape.html" title="A spatial object. Could be point, linestring, box or polygon, as specified by its &#39;dataType&#39; field.">Shape</a> constructor. <br /></td></tr>
<tr class="separator:aaa8d87171e65e0d8ba3c5459978992a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bb4edda98cdee8c8dc220acdee146f"><td class="memTemplParams" colspan="2"><a id="a01bb4edda98cdee8c8dc220acdee146f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01bb4edda98cdee8c8dc220acdee146f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a01bb4edda98cdee8c8dc220acdee146f">Shape</a> (T geom)</td></tr>
<tr class="memdesc:a01bb4edda98cdee8c8dc220acdee146f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default empty expicit type <a class="el" href="structShape.html" title="A spatial object. Could be point, linestring, box or polygon, as specified by its &#39;dataType&#39; field.">Shape</a> constructor. <br /></td></tr>
<tr class="separator:a01bb4edda98cdee8c8dc220acdee146f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fb0905466fef724cd58e29096645"><td class="memItemLeft" align="right" valign="top"><a id="a8357fb0905466fef724cd58e29096645"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getShapeType</b> () const</td></tr>
<tr class="separator:a8357fb0905466fef724cd58e29096645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ecabb468c90182381306982fbcc8da"><td class="memItemLeft" align="right" valign="top"><a id="a68ecabb468c90182381306982fbcc8da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a68ecabb468c90182381306982fbcc8da">setMBR</a> (double xMin, double yMin, double xMax, double yMax)</td></tr>
<tr class="memdesc:a68ecabb468c90182381306982fbcc8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the shape's mbr. If the max values are larger than the min values, it fixes this by swapping them. <br /></td></tr>
<tr class="separator:a68ecabb468c90182381306982fbcc8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e76d5baef174d767258b780d0109cbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a3e76d5baef174d767258b780d0109cbb">setMBR</a> ()</td></tr>
<tr class="memdesc:a3e76d5baef174d767258b780d0109cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="structMBR.html" title="Struct for Minimum Bounding Rectangles (MBR).">MBR</a> from the object's boost geometry envelope.  <a href="structShape.html#a3e76d5baef174d767258b780d0109cbb">More...</a><br /></td></tr>
<tr class="separator:a3e76d5baef174d767258b780d0109cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab008136f87074ce3b4fcec30ed04f3e9"><td class="memItemLeft" align="right" valign="top"><a id="ab008136f87074ce3b4fcec30ed04f3e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetMBR</b> ()</td></tr>
<tr class="separator:ab008136f87074ce3b4fcec30ed04f3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace10cbe3a8e046af74dff72b52e88aab"><td class="memItemLeft" align="right" valign="top"><a id="ace10cbe3a8e046af74dff72b52e88aab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetPoints</b> ()</td></tr>
<tr class="separator:ace10cbe3a8e046af74dff72b52e88aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092686033218ceb6e70f18c7431f90df"><td class="memItemLeft" align="right" valign="top"><a id="a092686033218ceb6e70f18c7431f90df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a092686033218ceb6e70f18c7431f90df">reset</a> ()</td></tr>
<tr class="memdesc:a092686033218ceb6e70f18c7431f90df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the boost geometry object. <br /></td></tr>
<tr class="separator:a092686033218ceb6e70f18c7431f90df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa890f29b52525ba1fcddcc48834114df"><td class="memItemLeft" align="right" valign="top"><a id="aa890f29b52525ba1fcddcc48834114df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#aa890f29b52525ba1fcddcc48834114df">addPoint</a> (const double x, const double y)</td></tr>
<tr class="memdesc:aa890f29b52525ba1fcddcc48834114df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a point to the boost geometry (see derived method definitions). <br /></td></tr>
<tr class="separator:aa890f29b52525ba1fcddcc48834114df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce053f37a7d3e8f85c40b6663d343aa"><td class="memItemLeft" align="right" valign="top"><a id="a6ce053f37a7d3e8f85c40b6663d343aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a6ce053f37a7d3e8f85c40b6663d343aa">correctGeometry</a> ()</td></tr>
<tr class="memdesc:a6ce053f37a7d3e8f85c40b6663d343aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrects the geometry object based on the boost geometry standards. <br /></td></tr>
<tr class="separator:a6ce053f37a7d3e8f85c40b6663d343aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9979341edc14cbec26583d1622b1b578"><td class="memItemLeft" align="right" valign="top"><a id="a9979341edc14cbec26583d1622b1b578"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a9979341edc14cbec26583d1622b1b578">setPoints</a> (std::vector&lt; double &gt; &amp;coords)</td></tr>
<tr class="memdesc:a9979341edc14cbec26583d1622b1b578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the shape's boost geometry points and <a class="el" href="structMBR.html" title="Struct for Minimum Bounding Rectangles (MBR).">MBR</a> to the new list. <br /></td></tr>
<tr class="separator:a9979341edc14cbec26583d1622b1b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df6fd4c9f8cd01b417c097af6b6e249"><td class="memItemLeft" align="right" valign="top"><a id="a6df6fd4c9f8cd01b417c097af6b6e249"></a>
DB_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>setFromWKT</b> (std::string wktText)</td></tr>
<tr class="separator:a6df6fd4c9f8cd01b417c097af6b6e249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3c5901abb9c867b38142f9f9f1110e"><td class="memItemLeft" align="right" valign="top"><a id="abe3c5901abb9c867b38142f9f9f1110e"></a>
DB_STATUS&#160;</td><td class="memItemRight" valign="bottom"><b>serializeCoordinates</b> (double **buffer, int &amp;bufferSize)</td></tr>
<tr class="separator:abe3c5901abb9c867b38142f9f9f1110e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865387b93e9f027d4923a51ae7ffe9cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a865387b93e9f027d4923a51ae7ffe9cc">modifyBoostPointByIndex</a> (int index, double x, double y)</td></tr>
<tr class="memdesc:a865387b93e9f027d4923a51ae7ffe9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the point specified by 'index' with the new values x,y. (see derived method definitions)  <a href="structShape.html#a865387b93e9f027d4923a51ae7ffe9cc">More...</a><br /></td></tr>
<tr class="separator:a865387b93e9f027d4923a51ae7ffe9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750738eec76251aae2586d061535c511"><td class="memItemLeft" align="right" valign="top"><a id="a750738eec76251aae2586d061535c511"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a750738eec76251aae2586d061535c511">printGeometry</a> ()</td></tr>
<tr class="memdesc:a750738eec76251aae2586d061535c511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the geometry. <br /></td></tr>
<tr class="separator:a750738eec76251aae2586d061535c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d6917e3c2fca75397c4130325a6754"><td class="memItemLeft" align="right" valign="top"><a id="ac7d6917e3c2fca75397c4130325a6754"></a>
const std::vector&lt; bg_point_xy &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#ac7d6917e3c2fca75397c4130325a6754">getReferenceToPoints</a> ()</td></tr>
<tr class="memdesc:ac7d6917e3c2fca75397c4130325a6754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the point list of the geometry. <br /></td></tr>
<tr class="separator:ac7d6917e3c2fca75397c4130325a6754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd4dd74fddde32ac5cbdb5c952d418f"><td class="memItemLeft" align="right" valign="top"><a id="afdd4dd74fddde32ac5cbdb5c952d418f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#afdd4dd74fddde32ac5cbdb5c952d418f">getVertexCount</a> ()</td></tr>
<tr class="memdesc:afdd4dd74fddde32ac5cbdb5c952d418f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the point count of the geometry. <br /></td></tr>
<tr class="separator:afdd4dd74fddde32ac5cbdb5c952d418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bceb50130d17c3d6d329ecf54b8da3c"><td class="memItemLeft" align="right" valign="top"><a id="a7bceb50130d17c3d6d329ecf54b8da3c"></a>
DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a7bceb50130d17c3d6d329ecf54b8da3c">getSpatialType</a> ()</td></tr>
<tr class="memdesc:a7bceb50130d17c3d6d329ecf54b8da3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the point count of the geometry. <br /></td></tr>
<tr class="separator:a7bceb50130d17c3d6d329ecf54b8da3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994926563f9b16870758f291497bae2e"><td class="memItemLeft" align="right" valign="top"><a id="a994926563f9b16870758f291497bae2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a994926563f9b16870758f291497bae2e">pipTest</a> (const bg_point_xy &amp;point) const</td></tr>
<tr class="memdesc:a994926563f9b16870758f291497bae2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a point-in-polygon test with the given point (see derived method definitions). <br /></td></tr>
<tr class="separator:a994926563f9b16870758f291497bae2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5735d6c5c38337ce7ed591e1134109"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a8d5735d6c5c38337ce7ed591e1134109">createMaskCode</a> (const <a class="el" href="structShape.html">Shape</a> &amp;other) const</td></tr>
<tr class="memdesc:a8d5735d6c5c38337ce7ed591e1134109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns the DE-9IM mask of this geometry (as R) with the input geometry (as S)  <a href="structShape.html#a8d5735d6c5c38337ce7ed591e1134109">More...</a><br /></td></tr>
<tr class="separator:a8d5735d6c5c38337ce7ed591e1134109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d2440d1569360d703d8e14a33eed8f"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:aa2d2440d1569360d703d8e14a33eed8f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#aa2d2440d1569360d703d8e14a33eed8f">distance</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:aa2d2440d1569360d703d8e14a33eed8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euclidean distance between the two objects.  <a href="structShape.html#aa2d2440d1569360d703d8e14a33eed8f">More...</a><br /></td></tr>
<tr class="separator:aa2d2440d1569360d703d8e14a33eed8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22831fc3dfdb466d31465814dff2e22"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#af22831fc3dfdb466d31465814dff2e22">distanceToPartition</a> (double xMin, double yMin, double xMax, double yMax) const</td></tr>
<tr class="memdesc:af22831fc3dfdb466d31465814dff2e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euclidean distance between the object and the given <a class="el" href="structMBR.html" title="Struct for Minimum Bounding Rectangles (MBR).">MBR</a>.  <a href="structShape.html#af22831fc3dfdb466d31465814dff2e22">More...</a><br /></td></tr>
<tr class="separator:af22831fc3dfdb466d31465814dff2e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d0ce4917c87fd456ff1b231f4d2dee"><td class="memItemLeft" align="right" valign="top"><a id="a63d0ce4917c87fd456ff1b231f4d2dee"></a>
std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getOverlappingPartitionOffsets</b> (int iCenter, int jCenter, double delta, double partitionExtentX, double partitionExtentY, double globalXmin, double globalYmin, int globalPPD) const</td></tr>
<tr class="separator:a63d0ce4917c87fd456ff1b231f4d2dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540f907bd548182b8b0ec4fcdd5e7b50"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a540f907bd548182b8b0ec4fcdd5e7b50"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a540f907bd548182b8b0ec4fcdd5e7b50">intersects</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a540f907bd548182b8b0ec4fcdd5e7b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the input geometry intersects (border or area) with this geometry. False otherwise.  <a href="structShape.html#a540f907bd548182b8b0ec4fcdd5e7b50">More...</a><br /></td></tr>
<tr class="separator:a540f907bd548182b8b0ec4fcdd5e7b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc85b84821bc9afe7042853334cded88"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:afc85b84821bc9afe7042853334cded88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#afc85b84821bc9afe7042853334cded88">disjoint</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:afc85b84821bc9afe7042853334cded88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the input geometry is disjoint (no common points) with this geometry. False otherwise.  <a href="structShape.html#afc85b84821bc9afe7042853334cded88">More...</a><br /></td></tr>
<tr class="separator:afc85b84821bc9afe7042853334cded88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0739ef5490685ef2c389e578fa26b361"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a0739ef5490685ef2c389e578fa26b361"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a0739ef5490685ef2c389e578fa26b361">inside</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a0739ef5490685ef2c389e578fa26b361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry is completely inside (no inside-border common points) the input geometry. False otherwise.  <a href="structShape.html#a0739ef5490685ef2c389e578fa26b361">More...</a><br /></td></tr>
<tr class="separator:a0739ef5490685ef2c389e578fa26b361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae917c6c1d29646e27534f4cdc65036fe"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:ae917c6c1d29646e27534f4cdc65036fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#ae917c6c1d29646e27534f4cdc65036fe">coveredBy</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:ae917c6c1d29646e27534f4cdc65036fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry is covered by (inside-border common points are allowed) the input geometry. False otherwise.  <a href="structShape.html#ae917c6c1d29646e27534f4cdc65036fe">More...</a><br /></td></tr>
<tr class="separator:ae917c6c1d29646e27534f4cdc65036fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b82933695d14e00333b3b8c19c3de1d"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a0b82933695d14e00333b3b8c19c3de1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a0b82933695d14e00333b3b8c19c3de1d">contains</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a0b82933695d14e00333b3b8c19c3de1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry completely contains (reverse of inside) the input geometry. False otherwise.  <a href="structShape.html#a0b82933695d14e00333b3b8c19c3de1d">More...</a><br /></td></tr>
<tr class="separator:a0b82933695d14e00333b3b8c19c3de1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c20890862aea7feb5bb0b74a2cdd015"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a7c20890862aea7feb5bb0b74a2cdd015"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a7c20890862aea7feb5bb0b74a2cdd015">covers</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a7c20890862aea7feb5bb0b74a2cdd015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry covers (reverse of covered by) the input geometry. False otherwise.  <a href="structShape.html#a7c20890862aea7feb5bb0b74a2cdd015">More...</a><br /></td></tr>
<tr class="separator:a7c20890862aea7feb5bb0b74a2cdd015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ef5ee8dc975e9aa9e73723cc052b26"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a30ef5ee8dc975e9aa9e73723cc052b26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a30ef5ee8dc975e9aa9e73723cc052b26">meets</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a30ef5ee8dc975e9aa9e73723cc052b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry meets (touches) the input geometry (their insides do not have common points, but their borders do). False otherwise.  <a href="structShape.html#a30ef5ee8dc975e9aa9e73723cc052b26">More...</a><br /></td></tr>
<tr class="separator:a30ef5ee8dc975e9aa9e73723cc052b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbb9b9a688078ae99af4c289626df60"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a2fbb9b9a688078ae99af4c289626df60"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a2fbb9b9a688078ae99af4c289626df60">equals</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a2fbb9b9a688078ae99af4c289626df60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry is spatially equal the input geometry. False otherwise.  <a href="structShape.html#a2fbb9b9a688078ae99af4c289626df60">More...</a><br /></td></tr>
<tr class="separator:a2fbb9b9a688078ae99af4c289626df60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a989ab9ff22efa8799a2c77cd64044fa6"><td class="memItemLeft" align="right" valign="top"><a id="a989ab9ff22efa8799a2c77cd64044fa6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a989ab9ff22efa8799a2c77cd64044fa6">recID</a></td></tr>
<tr class="memdesc:a989ab9ff22efa8799a2c77cd64044fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the object's ID, as read by the data file. <br /></td></tr>
<tr class="separator:a989ab9ff22efa8799a2c77cd64044fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e345146e379bc31887977626a1225e"><td class="memItemLeft" align="right" valign="top"><a id="af7e345146e379bc31887977626a1225e"></a>
<a class="el" href="structMBR.html">MBR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#af7e345146e379bc31887977626a1225e">mbr</a></td></tr>
<tr class="memdesc:af7e345146e379bc31887977626a1225e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the object's <a class="el" href="structMBR.html" title="Struct for Minimum Bounding Rectangles (MBR).">MBR</a>. <br /></td></tr>
<tr class="separator:af7e345146e379bc31887977626a1225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2b572292920401b4845c0938b6ddde"><td class="memItemLeft" align="right" valign="top"><a id="a3e2b572292920401b4845c0938b6ddde"></a>
<a class="el" href="structAprilData.html">AprilData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a3e2b572292920401b4845c0938b6ddde">aprilData</a></td></tr>
<tr class="memdesc:a3e2b572292920401b4845c0938b6ddde"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceAPRIL.html" title="APRIL related methods.">APRIL</a>. <br /></td></tr>
<tr class="separator:a3e2b572292920401b4845c0938b6ddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac093940974b1ec14bfcc42a04e3b2b26"><td class="memItemLeft" align="right" valign="top"><a id="ac093940974b1ec14bfcc42a04e3b2b26"></a>
DataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#ac093940974b1ec14bfcc42a04e3b2b26">type</a></td></tr>
<tr class="memdesc:ac093940974b1ec14bfcc42a04e3b2b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <a class="el" href="structShape.html" title="A spatial object. Could be point, linestring, box or polygon, as specified by its &#39;dataType&#39; field.">Shape</a> DataType for quick access <br /></td></tr>
<tr class="separator:ac093940974b1ec14bfcc42a04e3b2b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A spatial object. Could be point, linestring, box or polygon, as specified by its 'dataType' field. </p>
<p>All geometry wrappers are not meant to be visible to the user. Always use this struct for loading, querying or otherwise handling data. Extensions to the struct's methods require explicit definitions for the geometry types in the derived geometry structs. </p>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01230">1230</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0b82933695d14e00333b3b8c19c3de1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b82933695d14e00333b3b8c19c3de1d">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::contains </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry completely contains (reverse of inside) the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01500">1500</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;                                                            {</div>
<div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;                <span class="keywordflow">return</span> arg.contains(otherArg);</div>
<div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;        }, shape);</div>
<div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a0b82933695d14e00333b3b8c19c3de1d_icgraph.png" border="0" usemap="#astructShape_a0b82933695d14e00333b3b8c19c3de1d_icgraph" alt=""/></div>
<map name="astructShape_a0b82933695d14e00333b3b8c19c3de1d_icgraph" id="astructShape_a0b82933695d14e00333b3b8c19c3de1d_icgraph">
<area shape="rect" title="Returns true whether the geometry completely contains (reverse of inside) the input geometry...." alt="" coords="465,46,591,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#adf09fcf0850edaa6ba05852242e543af" title="Geometrically refines two objects for &#39;R contains S&#39;." alt="" coords="269,39,417,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#af99c4d3ea62a7338703048d3b31b158c" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,221,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a092ec15a5d78cf8615bfeb72972436d1" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,197,112"/>
</map>
</div>

</div>
</div>
<a id="ae917c6c1d29646e27534f4cdc65036fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae917c6c1d29646e27534f4cdc65036fe">&#9670;&nbsp;</a></span>coveredBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::coveredBy </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry is covered by (inside-border common points are allowed) the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01488">1488</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;                                                             {</div>
<div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;                <span class="keywordflow">return</span> arg.inside(otherArg);</div>
<div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;        }, shape);</div>
<div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_ae917c6c1d29646e27534f4cdc65036fe_icgraph.png" border="0" usemap="#astructShape_ae917c6c1d29646e27534f4cdc65036fe_icgraph" alt=""/></div>
<map name="astructShape_ae917c6c1d29646e27534f4cdc65036fe_icgraph" id="astructShape_ae917c6c1d29646e27534f4cdc65036fe_icgraph">
<area shape="rect" title="Returns true whether the geometry is covered by (inside&#45;border common points are allowed) the input g..." alt="" coords="480,46,619,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#ace238e193dd0c0d54eeda0c081202505" title="Geometrically refines two objects for &#39;R is covered by S&#39;." alt="" coords="269,39,432,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#af99c4d3ea62a7338703048d3b31b158c" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,221,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a092ec15a5d78cf8615bfeb72972436d1" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,197,112"/>
</map>
</div>

</div>
</div>
<a id="a7c20890862aea7feb5bb0b74a2cdd015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c20890862aea7feb5bb0b74a2cdd015">&#9670;&nbsp;</a></span>covers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::covers </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry covers (reverse of covered by) the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01512">1512</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;                                                          {</div>
<div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;                <span class="keywordflow">return</span> arg.contains(otherArg);</div>
<div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;        }, shape);</div>
<div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a7c20890862aea7feb5bb0b74a2cdd015_icgraph.png" border="0" usemap="#astructShape_a7c20890862aea7feb5bb0b74a2cdd015_icgraph" alt=""/></div>
<map name="astructShape_a7c20890862aea7feb5bb0b74a2cdd015_icgraph" id="astructShape_a7c20890862aea7feb5bb0b74a2cdd015_icgraph">
<area shape="rect" title="Returns true whether the geometry covers (reverse of covered by) the input geometry...." alt="" coords="456,46,569,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#ab68df5defc474b421b7aafed80723c32" title="Geometrically refines two objects for &#39;R covers S&#39;." alt="" coords="269,39,408,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#af99c4d3ea62a7338703048d3b31b158c" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,221,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a092ec15a5d78cf8615bfeb72972436d1" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,197,112"/>
</map>
</div>

</div>
</div>
<a id="a8d5735d6c5c38337ce7ed591e1134109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5735d6c5c38337ce7ed591e1134109">&#9670;&nbsp;</a></span>createMaskCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Shape::createMaskCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structShape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates and returns the DE-9IM mask of this geometry (as R) with the input geometry (as S) </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01408">1408</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;                                                       {</div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; std::string {</div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; std::string {</div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;                <span class="keywordflow">return</span> arg.createMaskCode(otherArg);</div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;        }, shape);</div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a8d5735d6c5c38337ce7ed591e1134109_icgraph.png" border="0" usemap="#astructShape_a8d5735d6c5c38337ce7ed591e1134109_icgraph" alt=""/></div>
<map name="astructShape_a8d5735d6c5c38337ce7ed591e1134109_icgraph" id="astructShape_a8d5735d6c5c38337ce7ed591e1134109_icgraph">
<area shape="rect" title="Generates and returns the DE&#45;9IM mask of this geometry (as R) with the input geometry (as S)" alt="" coords="587,313,765,340"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#ad8c462df79c6496f979cf90b53f724b7" title="Refines for the contains and covers relation predicates, with the intersection being guaranteed." alt="" coords="312,5,525,61"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#afbacbdc86abf29312cdfa8c244968ca5" title="Refines for the covered relation predicate, with the intersection being guaranteed." alt="" coords="299,86,539,127"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a3e5007018514e095e047ee36e6c90e5c" title="Refines for the covers and covered by relation predicates, with the intersection being guaranteed." alt="" coords="313,152,524,208"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a7447c70dc90eb8f3d97de3645a1ea76e" title="Refines for the covers relation predicate, with the intersection being guaranteed." alt="" coords="311,233,526,274"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#aec20a5185db33b1779abf1b0d7b34927" title="Refines for the disjoint, contains, covers, meet and intersect relation predicates." alt="" coords="309,299,528,355"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#acbdd7cbf94855d2c82504a4b8b166af2" title="Refines for the disjoint, inside, covered by, meet and intersect relation predicates." alt="" coords="305,379,532,435"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#add8085cd6429c5f10bf831b05911db86" title="Refines for the disjoint, meet and intersect relation predicates (no containment)." alt="" coords="315,459,522,501"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a3fd63d20c3438256591e901526ab8b5d" title="Refines for the equals, covers and covered by relation predicates, with the intersection being guaran..." alt="" coords="309,525,528,581"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a54dd50193b0c8294882174fae9f313cf" title="Refines for the inside and covered by relation predicates, with the intersection being guaranteed." alt="" coords="309,605,529,661"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a84259591d1fe3bf816c78e179bfc7f6b" title="Entrypoint function for topological relationship refinement, for when there is NO intermediate filter..." alt="" coords="5,386,251,427"/>
</map>
</div>

</div>
</div>
<a id="afc85b84821bc9afe7042853334cded88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc85b84821bc9afe7042853334cded88">&#9670;&nbsp;</a></span>disjoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::disjoint </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the input geometry is disjoint (no common points) with this geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01464">1464</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;                                                            {</div>
<div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;                <span class="keywordflow">return</span> arg.disjoint(otherArg);</div>
<div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;        }, shape);</div>
<div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_afc85b84821bc9afe7042853334cded88_icgraph.png" border="0" usemap="#astructShape_afc85b84821bc9afe7042853334cded88_icgraph" alt=""/></div>
<map name="astructShape_afc85b84821bc9afe7042853334cded88_icgraph" id="astructShape_afc85b84821bc9afe7042853334cded88_icgraph">
<area shape="rect" title="Returns true whether the input geometry is disjoint (no common points) with this geometry...." alt="" coords="459,46,577,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a55a81d174754ed3ec99fa3a6f97f869f" title="Geometrically refines two objects for whether they are disjoint." alt="" coords="269,39,411,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#af99c4d3ea62a7338703048d3b31b158c" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,221,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a092ec15a5d78cf8615bfeb72972436d1" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,197,112"/>
</map>
</div>

</div>
</div>
<a id="aa2d2440d1569360d703d8e14a33eed8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d2440d1569360d703d8e14a33eed8f">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Shape::distance </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Euclidean distance between the two objects. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01420">1420</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;                                                              {</div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;                <span class="keywordflow">return</span> arg.distance(otherArg);</div>
<div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;        }, shape);</div>
<div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af22831fc3dfdb466d31465814dff2e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22831fc3dfdb466d31465814dff2e22">&#9670;&nbsp;</a></span>distanceToPartition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Shape::distanceToPartition </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Euclidean distance between the object and the given <a class="el" href="structMBR.html" title="Struct for Minimum Bounding Rectangles (MBR).">MBR</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01431">1431</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;                                                                                         {</div>
<div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;        <span class="keywordflow">return</span> std::visit([xMin, yMin, xMax, yMax](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">double</span> {</div>
<div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;            <span class="keywordflow">return</span> arg.distanceToPartition(xMin, yMin, xMax, yMax);</div>
<div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;        }, shape);</div>
<div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;    }   </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fbb9b9a688078ae99af4c289626df60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbb9b9a688078ae99af4c289626df60">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::equals </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry is spatially equal the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01537">1537</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;                                                          {</div>
<div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;                <span class="keywordflow">return</span> arg.equals(otherArg);</div>
<div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;        }, shape);</div>
<div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a2fbb9b9a688078ae99af4c289626df60_icgraph.png" border="0" usemap="#astructShape_a2fbb9b9a688078ae99af4c289626df60_icgraph" alt=""/></div>
<map name="astructShape_a2fbb9b9a688078ae99af4c289626df60_icgraph" id="astructShape_a2fbb9b9a688078ae99af4c289626df60_icgraph">
<area shape="rect" title="Returns true whether the geometry is spatially equal the input geometry. False otherwise." alt="" coords="456,46,569,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a919f6dc96f5057a795445a5b679a8ae6" title="Returns true of the two objects are spatially equal." alt="" coords="269,5,408,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#aec5965234565ec1ec3eee6121b90c112" title="Geometrically refines two objects for spatial equality." alt="" coords="269,71,408,112"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#af99c4d3ea62a7338703048d3b31b158c" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,37,221,79"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a092ec15a5d78cf8615bfeb72972436d1" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,103,197,144"/>
</map>
</div>

</div>
</div>
<a id="a0739ef5490685ef2c389e578fa26b361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0739ef5490685ef2c389e578fa26b361">&#9670;&nbsp;</a></span>inside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::inside </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry is completely inside (no inside-border common points) the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01476">1476</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;                                                          {</div>
<div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;                <span class="keywordflow">return</span> arg.inside(otherArg);</div>
<div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;        }, shape);</div>
<div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a0739ef5490685ef2c389e578fa26b361_icgraph.png" border="0" usemap="#astructShape_a0739ef5490685ef2c389e578fa26b361_icgraph" alt=""/></div>
<map name="astructShape_a0739ef5490685ef2c389e578fa26b361_icgraph" id="astructShape_a0739ef5490685ef2c389e578fa26b361_icgraph">
<area shape="rect" title="Returns true whether the geometry is completely inside (no inside&#45;border common points) the input geo..." alt="" coords="456,46,565,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a22d26a184e94020bc7fe4198560f98a7" title="Geometrically refines two objects for &#39;R inside S&#39;." alt="" coords="269,39,408,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#af99c4d3ea62a7338703048d3b31b158c" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,221,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a092ec15a5d78cf8615bfeb72972436d1" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,197,112"/>
</map>
</div>

</div>
</div>
<a id="a540f907bd548182b8b0ec4fcdd5e7b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540f907bd548182b8b0ec4fcdd5e7b50">&#9670;&nbsp;</a></span>intersects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::intersects </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the input geometry intersects (border or area) with this geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01452">1452</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;                                                              {</div>
<div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;                <span class="keywordflow">return</span> arg.intersects(otherArg);</div>
<div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;        }, shape);</div>
<div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a540f907bd548182b8b0ec4fcdd5e7b50_icgraph.png" border="0" usemap="#astructShape_a540f907bd548182b8b0ec4fcdd5e7b50_icgraph" alt=""/></div>
<map name="astructShape_a540f907bd548182b8b0ec4fcdd5e7b50_icgraph" id="astructShape_a540f907bd548182b8b0ec4fcdd5e7b50_icgraph">
<area shape="rect" title="Returns true whether the input geometry intersects (border or area) with this geometry...." alt="" coords="485,46,620,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a5db75d82c0cde92eff14c7bd1e9dc4c3" title="Geometrically refines two objects for intersection." alt="" coords="269,5,437,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a5bc53ca8ab0bc9ac0fb928a5b603ac9d" title="Geometrically refines a window (polygon or box) with the given shape. Appends only the object&#39;s id as..." alt="" coords="284,71,423,112"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#af99c4d3ea62a7338703048d3b31b158c" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,221,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a092ec15a5d78cf8615bfeb72972436d1" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,197,112"/>
</map>
</div>

</div>
</div>
<a id="a30ef5ee8dc975e9aa9e73723cc052b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ef5ee8dc975e9aa9e73723cc052b26">&#9670;&nbsp;</a></span>meets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::meets </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry meets (touches) the input geometry (their insides do not have common points, but their borders do). False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01525">1525</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;                                                         {</div>
<div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;                <span class="keywordflow">return</span> arg.meets(otherArg);</div>
<div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;        }, shape);</div>
<div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a30ef5ee8dc975e9aa9e73723cc052b26_icgraph.png" border="0" usemap="#astructShape_a30ef5ee8dc975e9aa9e73723cc052b26_icgraph" alt=""/></div>
<map name="astructShape_a30ef5ee8dc975e9aa9e73723cc052b26_icgraph" id="astructShape_a30ef5ee8dc975e9aa9e73723cc052b26_icgraph">
<area shape="rect" title="Returns true whether the geometry meets (touches) the input geometry (their insides do not have commo..." alt="" coords="461,46,572,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#aa8da2292354b906ad94b60cdbb091088" title="Returns true of the two objects meet (touch)." alt="" coords="275,5,413,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#aa75c2df3796fc0a075bcec6d39e026a3" title="Geometrically refines two objects for whether R and S meet (touch)." alt="" coords="275,71,413,112"/>
<area shape="rect" href="namespaceAPRIL_1_1uncompressed_1_1topology.html#a54bb1f423be311c97eb95a4fd331f371" title="Joins APRIL approximations for topological relations when two MBRs are equal." alt="" coords="5,5,227,47"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#af99c4d3ea62a7338703048d3b31b158c" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="8,71,224,112"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a092ec15a5d78cf8615bfeb72972436d1" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="32,136,200,177"/>
</map>
</div>

</div>
</div>
<a id="a865387b93e9f027d4923a51ae7ffe9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865387b93e9f027d4923a51ae7ffe9cc">&#9670;&nbsp;</a></span>modifyBoostPointByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::modifyBoostPointByIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies the point specified by 'index' with the new values x,y. (see derived method definitions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the point to modify in the geometry object. </td></tr>
    <tr><td class="paramname">x</td><td>The new x value. </td></tr>
    <tr><td class="paramname">y</td><td>The new y value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01363">1363</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;                                                                {</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;        std::visit([index, &amp;x, &amp;y](<span class="keyword">auto</span>&amp;&amp; arg) {</div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;            arg.modifyBoostPointByIndex(index, x, y);</div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;        }, shape);</div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e76d5baef174d767258b780d0109cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e76d5baef174d767258b780d0109cbb">&#9670;&nbsp;</a></span>setMBR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::setMBR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="structMBR.html" title="Struct for Minimum Bounding Rectangles (MBR).">MBR</a> from the object's boost geometry envelope. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>: move this inside the setFromWKT() to avoid calling it manually after each setFromWKT() </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2containers_8h_source.html#l01284">1284</a> of file <a class="el" href="include_2containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;                         {</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;        bg_box envelope;</div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;        <span class="comment">// get envelope from boost</span></div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;        std::visit([&amp;](<span class="keyword">auto</span>&amp;&amp; arg) {</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;            arg.getBoostEnvelope(envelope);</div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;        }, shape);</div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;        <span class="comment">// set mbr</span></div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;        <a class="code" href="structShape.html#af7e345146e379bc31887977626a1225e">mbr</a>.pMin.x = envelope.min_corner().x();</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;        <a class="code" href="structShape.html#af7e345146e379bc31887977626a1225e">mbr</a>.pMin.y = envelope.min_corner().y();</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;        <a class="code" href="structShape.html#af7e345146e379bc31887977626a1225e">mbr</a>.pMax.x = envelope.max_corner().x();</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;        <a class="code" href="structShape.html#af7e345146e379bc31887977626a1225e">mbr</a>.pMax.y = envelope.max_corner().y();</div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;    }</div>
<div class="ttc" id="astructShape_html_af7e345146e379bc31887977626a1225e"><div class="ttname"><a href="structShape.html#af7e345146e379bc31887977626a1225e">Shape::mbr</a></div><div class="ttdeci">MBR mbr</div><div class="ttdoc">the object's MBR.</div><div class="ttdef"><b>Definition:</b> <a href="include_2containers_8h_source.html#l01242">containers.h:1242</a></div></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Hecatoncheir/include/<a class="el" href="include_2containers_8h_source.html">containers.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hecatoncheir: Shape Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hecatoncheir
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">code documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structShape-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Shape Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A spatial object. Could be point, linestring, rectangle or polygon, as specified by its 'dataType' field.  
 <a href="structShape.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="containers_8h_source.html">containers.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Shape:</div>
<div class="dyncontent">
<div class="center"><img src="structShape__coll__graph.png" border="0" usemap="#aShape_coll__map" alt="Collaboration graph"/></div>
<map name="aShape_coll__map" id="aShape_coll__map">
<area shape="rect" title="A spatial object. Could be point, linestring, rectangle or polygon, as specified by its &#39;dataType&#39; fi..." alt="" coords="5,199,64,225"/>
<area shape="rect" href="structMBR.html" title="Struct for Minimum Bounding Rectangles (MBR)." alt="" coords="9,109,61,136"/>
<area shape="rect" href="structPoint.html" title="Struct for 2&#45;dimension points with double coordinates x and y (lon, lat)." alt="" coords="9,5,61,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaa8d87171e65e0d8ba3c5459978992a7"><td class="memItemLeft" align="right" valign="top"><a id="aaa8d87171e65e0d8ba3c5459978992a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#aaa8d87171e65e0d8ba3c5459978992a7">Shape</a> ()</td></tr>
<tr class="memdesc:aaa8d87171e65e0d8ba3c5459978992a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default empty <a class="el" href="structShape.html" title="A spatial object. Could be point, linestring, rectangle or polygon, as specified by its &#39;dataType&#39; fi...">Shape</a> constructor. <br /></td></tr>
<tr class="separator:aaa8d87171e65e0d8ba3c5459978992a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bb4edda98cdee8c8dc220acdee146f"><td class="memTemplParams" colspan="2"><a id="a01bb4edda98cdee8c8dc220acdee146f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01bb4edda98cdee8c8dc220acdee146f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a01bb4edda98cdee8c8dc220acdee146f">Shape</a> (T geom)</td></tr>
<tr class="memdesc:a01bb4edda98cdee8c8dc220acdee146f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default empty expicit type <a class="el" href="structShape.html" title="A spatial object. Could be point, linestring, rectangle or polygon, as specified by its &#39;dataType&#39; fi...">Shape</a> constructor. <br /></td></tr>
<tr class="separator:a01bb4edda98cdee8c8dc220acdee146f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8357fb0905466fef724cd58e29096645"><td class="memItemLeft" align="right" valign="top"><a id="a8357fb0905466fef724cd58e29096645"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getShapeType</b> () const</td></tr>
<tr class="separator:a8357fb0905466fef724cd58e29096645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa890f29b52525ba1fcddcc48834114df"><td class="memItemLeft" align="right" valign="top"><a id="aa890f29b52525ba1fcddcc48834114df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#aa890f29b52525ba1fcddcc48834114df">addPoint</a> (const double x, const double y)</td></tr>
<tr class="memdesc:aa890f29b52525ba1fcddcc48834114df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a point to the boost geometry (see derived method definitions). <br /></td></tr>
<tr class="separator:aa890f29b52525ba1fcddcc48834114df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce053f37a7d3e8f85c40b6663d343aa"><td class="memItemLeft" align="right" valign="top"><a id="a6ce053f37a7d3e8f85c40b6663d343aa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a6ce053f37a7d3e8f85c40b6663d343aa">correctGeometry</a> ()</td></tr>
<tr class="memdesc:a6ce053f37a7d3e8f85c40b6663d343aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Corrects the geometry object based on the boost geometry standards. <br /></td></tr>
<tr class="separator:a6ce053f37a7d3e8f85c40b6663d343aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865387b93e9f027d4923a51ae7ffe9cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a865387b93e9f027d4923a51ae7ffe9cc">modifyBoostPointByIndex</a> (int index, double x, double y)</td></tr>
<tr class="memdesc:a865387b93e9f027d4923a51ae7ffe9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the point specified by 'index' with the new values x,y. (see derived method definitions)  <a href="structShape.html#a865387b93e9f027d4923a51ae7ffe9cc">More...</a><br /></td></tr>
<tr class="separator:a865387b93e9f027d4923a51ae7ffe9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750738eec76251aae2586d061535c511"><td class="memItemLeft" align="right" valign="top"><a id="a750738eec76251aae2586d061535c511"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a750738eec76251aae2586d061535c511">printGeometry</a> ()</td></tr>
<tr class="memdesc:a750738eec76251aae2586d061535c511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the geometry. <br /></td></tr>
<tr class="separator:a750738eec76251aae2586d061535c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092686033218ceb6e70f18c7431f90df"><td class="memItemLeft" align="right" valign="top"><a id="a092686033218ceb6e70f18c7431f90df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a092686033218ceb6e70f18c7431f90df">reset</a> ()</td></tr>
<tr class="memdesc:a092686033218ceb6e70f18c7431f90df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the boost geometry object. <br /></td></tr>
<tr class="separator:a092686033218ceb6e70f18c7431f90df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d6917e3c2fca75397c4130325a6754"><td class="memItemLeft" align="right" valign="top"><a id="ac7d6917e3c2fca75397c4130325a6754"></a>
const std::vector&lt; bg_point_xy &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#ac7d6917e3c2fca75397c4130325a6754">getReferenceToPoints</a> ()</td></tr>
<tr class="memdesc:ac7d6917e3c2fca75397c4130325a6754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the point list of the geometry. <br /></td></tr>
<tr class="separator:ac7d6917e3c2fca75397c4130325a6754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd4dd74fddde32ac5cbdb5c952d418f"><td class="memItemLeft" align="right" valign="top"><a id="afdd4dd74fddde32ac5cbdb5c952d418f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#afdd4dd74fddde32ac5cbdb5c952d418f">getVertexCount</a> ()</td></tr>
<tr class="memdesc:afdd4dd74fddde32ac5cbdb5c952d418f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the point count of the geometry. <br /></td></tr>
<tr class="separator:afdd4dd74fddde32ac5cbdb5c952d418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994926563f9b16870758f291497bae2e"><td class="memItemLeft" align="right" valign="top"><a id="a994926563f9b16870758f291497bae2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a994926563f9b16870758f291497bae2e">pipTest</a> (const bg_point_xy &amp;point) const</td></tr>
<tr class="memdesc:a994926563f9b16870758f291497bae2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a point-in-polygon test with the given point (see derived method definitions). <br /></td></tr>
<tr class="separator:a994926563f9b16870758f291497bae2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5735d6c5c38337ce7ed591e1134109"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a8d5735d6c5c38337ce7ed591e1134109">createMaskCode</a> (const <a class="el" href="structShape.html">Shape</a> &amp;other) const</td></tr>
<tr class="memdesc:a8d5735d6c5c38337ce7ed591e1134109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and returns the DE-9IM mask of this geometry (as R) with the input geometry (as S)  <a href="structShape.html#a8d5735d6c5c38337ce7ed591e1134109">More...</a><br /></td></tr>
<tr class="separator:a8d5735d6c5c38337ce7ed591e1134109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540f907bd548182b8b0ec4fcdd5e7b50"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a540f907bd548182b8b0ec4fcdd5e7b50"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a540f907bd548182b8b0ec4fcdd5e7b50">intersects</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a540f907bd548182b8b0ec4fcdd5e7b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the input geometry intersects (border or area) with this geometry. False otherwise.  <a href="structShape.html#a540f907bd548182b8b0ec4fcdd5e7b50">More...</a><br /></td></tr>
<tr class="separator:a540f907bd548182b8b0ec4fcdd5e7b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc85b84821bc9afe7042853334cded88"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:afc85b84821bc9afe7042853334cded88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#afc85b84821bc9afe7042853334cded88">disjoint</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:afc85b84821bc9afe7042853334cded88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the input geometry is disjoint (no common points) with this geometry. False otherwise.  <a href="structShape.html#afc85b84821bc9afe7042853334cded88">More...</a><br /></td></tr>
<tr class="separator:afc85b84821bc9afe7042853334cded88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0739ef5490685ef2c389e578fa26b361"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a0739ef5490685ef2c389e578fa26b361"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a0739ef5490685ef2c389e578fa26b361">inside</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a0739ef5490685ef2c389e578fa26b361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry is completely inside (no inside-border common points) the input geometry. False otherwise.  <a href="structShape.html#a0739ef5490685ef2c389e578fa26b361">More...</a><br /></td></tr>
<tr class="separator:a0739ef5490685ef2c389e578fa26b361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae917c6c1d29646e27534f4cdc65036fe"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:ae917c6c1d29646e27534f4cdc65036fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#ae917c6c1d29646e27534f4cdc65036fe">coveredBy</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:ae917c6c1d29646e27534f4cdc65036fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry is covered by (inside-border common points are allowed) the input geometry. False otherwise.  <a href="structShape.html#ae917c6c1d29646e27534f4cdc65036fe">More...</a><br /></td></tr>
<tr class="separator:ae917c6c1d29646e27534f4cdc65036fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b82933695d14e00333b3b8c19c3de1d"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a0b82933695d14e00333b3b8c19c3de1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a0b82933695d14e00333b3b8c19c3de1d">contains</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a0b82933695d14e00333b3b8c19c3de1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry completely contains (reverse of inside) the input geometry. False otherwise.  <a href="structShape.html#a0b82933695d14e00333b3b8c19c3de1d">More...</a><br /></td></tr>
<tr class="separator:a0b82933695d14e00333b3b8c19c3de1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c20890862aea7feb5bb0b74a2cdd015"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a7c20890862aea7feb5bb0b74a2cdd015"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a7c20890862aea7feb5bb0b74a2cdd015">covers</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a7c20890862aea7feb5bb0b74a2cdd015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry covers (reverse of covered by) the input geometry. False otherwise.  <a href="structShape.html#a7c20890862aea7feb5bb0b74a2cdd015">More...</a><br /></td></tr>
<tr class="separator:a7c20890862aea7feb5bb0b74a2cdd015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ef5ee8dc975e9aa9e73723cc052b26"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a30ef5ee8dc975e9aa9e73723cc052b26"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a30ef5ee8dc975e9aa9e73723cc052b26">meets</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a30ef5ee8dc975e9aa9e73723cc052b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry meets (touches) the input geometry (their insides do not have common points, but their borders do). False otherwise.  <a href="structShape.html#a30ef5ee8dc975e9aa9e73723cc052b26">More...</a><br /></td></tr>
<tr class="separator:a30ef5ee8dc975e9aa9e73723cc052b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbb9b9a688078ae99af4c289626df60"><td class="memTemplParams" colspan="2">template&lt;typename OtherBoostGeometryObj &gt; </td></tr>
<tr class="memitem:a2fbb9b9a688078ae99af4c289626df60"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structShape.html#a2fbb9b9a688078ae99af4c289626df60">equals</a> (const OtherBoostGeometryObj &amp;other) const</td></tr>
<tr class="memdesc:a2fbb9b9a688078ae99af4c289626df60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true whether the geometry is spatially equal the input geometry. False otherwise.  <a href="structShape.html#a2fbb9b9a688078ae99af4c289626df60">More...</a><br /></td></tr>
<tr class="separator:a2fbb9b9a688078ae99af4c289626df60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a989ab9ff22efa8799a2c77cd64044fa6"><td class="memItemLeft" align="right" valign="top"><a id="a989ab9ff22efa8799a2c77cd64044fa6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#a989ab9ff22efa8799a2c77cd64044fa6">recID</a></td></tr>
<tr class="memdesc:a989ab9ff22efa8799a2c77cd64044fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the object's ID, as read by the data file. <br /></td></tr>
<tr class="separator:a989ab9ff22efa8799a2c77cd64044fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e345146e379bc31887977626a1225e"><td class="memItemLeft" align="right" valign="top"><a id="af7e345146e379bc31887977626a1225e"></a>
<a class="el" href="structMBR.html">MBR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#af7e345146e379bc31887977626a1225e">mbr</a></td></tr>
<tr class="memdesc:af7e345146e379bc31887977626a1225e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the object's <a class="el" href="structMBR.html" title="Struct for Minimum Bounding Rectangles (MBR).">MBR</a>. <br /></td></tr>
<tr class="separator:af7e345146e379bc31887977626a1225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae160e73c713890a7f23e91a133b30dad"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; size_t, TwoLayerClassE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structShape.html#ae160e73c713890a7f23e91a133b30dad">partitions</a></td></tr>
<tr class="memdesc:ae160e73c713890a7f23e91a133b30dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The object's partition index, containing info about the partitions that this object intersects with and its two-layer index class in each of them.  <a href="structShape.html#ae160e73c713890a7f23e91a133b30dad">More...</a><br /></td></tr>
<tr class="separator:ae160e73c713890a7f23e91a133b30dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A spatial object. Could be point, linestring, rectangle or polygon, as specified by its 'dataType' field. </p>
<p>All geometry wrappers are not meant to be visible to the user. Always use this struct for loading, querying or otherwise handling data. Extensions to the struct's methods require explicit definitions for the geometry types in the derived geometry structs. </p>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00719">719</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0b82933695d14e00333b3b8c19c3de1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b82933695d14e00333b3b8c19c3de1d">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::contains </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry completely contains (reverse of inside) the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00892">892</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;                                                            {</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;                <span class="keywordflow">return</span> arg.contains(otherArg);</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;        }, shape);</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a0b82933695d14e00333b3b8c19c3de1d_icgraph.png" border="0" usemap="#astructShape_a0b82933695d14e00333b3b8c19c3de1d_icgraph" alt=""/></div>
<map name="astructShape_a0b82933695d14e00333b3b8c19c3de1d_icgraph" id="astructShape_a0b82933695d14e00333b3b8c19c3de1d_icgraph">
<area shape="rect" title="Returns true whether the geometry completely contains (reverse of inside) the input geometry...." alt="" coords="439,46,555,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a6175d4fbcda97dae7d64993422b71adc" title="Geometrically refines two objects for &#39;R contains S&#39;." alt="" coords="252,39,391,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#ad2a3e148599958aca40c3f3848ca75cc" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,204,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a8648ae83cd8bee000ca1b5bd0ae0eddf" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,180,112"/>
</map>
</div>

</div>
</div>
<a id="ae917c6c1d29646e27534f4cdc65036fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae917c6c1d29646e27534f4cdc65036fe">&#9670;&nbsp;</a></span>coveredBy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::coveredBy </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry is covered by (inside-border common points are allowed) the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00880">880</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;                                                             {</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;                <span class="keywordflow">return</span> arg.inside(otherArg);</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;        }, shape);</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_ae917c6c1d29646e27534f4cdc65036fe_icgraph.png" border="0" usemap="#astructShape_ae917c6c1d29646e27534f4cdc65036fe_icgraph" alt=""/></div>
<map name="astructShape_ae917c6c1d29646e27534f4cdc65036fe_icgraph" id="astructShape_ae917c6c1d29646e27534f4cdc65036fe_icgraph">
<area shape="rect" title="Returns true whether the geometry is covered by (inside&#45;border common points are allowed) the input g..." alt="" coords="451,46,580,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a739bba1d8643086cc692f4317a732d46" title="Geometrically refines two objects for &#39;R is covered by S&#39;." alt="" coords="252,39,403,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#ad2a3e148599958aca40c3f3848ca75cc" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,204,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a8648ae83cd8bee000ca1b5bd0ae0eddf" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,180,112"/>
</map>
</div>

</div>
</div>
<a id="a7c20890862aea7feb5bb0b74a2cdd015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c20890862aea7feb5bb0b74a2cdd015">&#9670;&nbsp;</a></span>covers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::covers </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry covers (reverse of covered by) the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00904">904</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;                                                          {</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;                <span class="keywordflow">return</span> arg.contains(otherArg);</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;        }, shape);</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a7c20890862aea7feb5bb0b74a2cdd015_icgraph.png" border="0" usemap="#astructShape_a7c20890862aea7feb5bb0b74a2cdd015_icgraph" alt=""/></div>
<map name="astructShape_a7c20890862aea7feb5bb0b74a2cdd015_icgraph" id="astructShape_a7c20890862aea7feb5bb0b74a2cdd015_icgraph">
<area shape="rect" title="Returns true whether the geometry covers (reverse of covered by) the input geometry...." alt="" coords="428,46,535,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#aac3f443ae4936280082ebc32e3f16d81" title="Geometrically refines two objects for &#39;R covers S&#39;." alt="" coords="252,39,380,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#ad2a3e148599958aca40c3f3848ca75cc" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,204,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a8648ae83cd8bee000ca1b5bd0ae0eddf" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,180,112"/>
</map>
</div>

</div>
</div>
<a id="a8d5735d6c5c38337ce7ed591e1134109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5735d6c5c38337ce7ed591e1134109">&#9670;&nbsp;</a></span>createMaskCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Shape::createMaskCode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structShape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates and returns the DE-9IM mask of this geometry (as R) with the input geometry (as S) </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00832">832</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;                                                       {</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; std::string {</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; std::string {</div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;                <span class="keywordflow">return</span> arg.createMaskCode(otherArg);</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;        }, shape);</div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a8d5735d6c5c38337ce7ed591e1134109_icgraph.png" border="0" usemap="#astructShape_a8d5735d6c5c38337ce7ed591e1134109_icgraph" alt=""/></div>
<map name="astructShape_a8d5735d6c5c38337ce7ed591e1134109_icgraph" id="astructShape_a8d5735d6c5c38337ce7ed591e1134109_icgraph">
<area shape="rect" title="Generates and returns the DE&#45;9IM mask of this geometry (as R) with the input geometry (as S)" alt="" coords="541,313,708,340"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#ad8c462df79c6496f979cf90b53f724b7" title="Refines for the contains and covers relation predicates, with the intersection being guaranteed." alt="" coords="286,5,482,61"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#afbacbdc86abf29312cdfa8c244968ca5" title="Refines for the covered relation predicate, with the intersection being guaranteed." alt="" coords="275,86,493,127"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a3e5007018514e095e047ee36e6c90e5c" title="Refines for the covers and covered by relation predicates, with the intersection being guaranteed." alt="" coords="287,152,481,208"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a7447c70dc90eb8f3d97de3645a1ea76e" title="Refines for the covers relation predicate, with the intersection being guaranteed." alt="" coords="285,233,483,274"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#aec20a5185db33b1779abf1b0d7b34927" title="Refines for the disjoint, contains, covers, meet and intersect relation predicates." alt="" coords="284,299,484,355"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#acbdd7cbf94855d2c82504a4b8b166af2" title="Refines for the disjoint, inside, covered by, meet and intersect relation predicates." alt="" coords="282,379,486,435"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#add8085cd6429c5f10bf831b05911db86" title="Refines for the disjoint, meet and intersect relation predicates (no containment)." alt="" coords="291,459,477,501"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a3fd63d20c3438256591e901526ab8b5d" title="Refines for the equals, covers and covered by relation predicates, with the intersection being guaran..." alt="" coords="283,525,485,581"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a54dd50193b0c8294882174fae9f313cf" title="Refines for the inside and covered by relation predicates, with the intersection being guaranteed." alt="" coords="284,605,484,661"/>
<area shape="rect" href="namespacerefinement_1_1topology.html#a1ebebb763f209a69db4c54ff227812c6" title="Entrypoint function for topological relationship refinement, for when there is NO intermediate filter..." alt="" coords="5,386,227,427"/>
</map>
</div>

</div>
</div>
<a id="afc85b84821bc9afe7042853334cded88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc85b84821bc9afe7042853334cded88">&#9670;&nbsp;</a></span>disjoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::disjoint </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the input geometry is disjoint (no common points) with this geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00856">856</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                                                            {</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;                <span class="keywordflow">return</span> arg.disjoint(otherArg);</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;        }, shape);</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_afc85b84821bc9afe7042853334cded88_icgraph.png" border="0" usemap="#astructShape_afc85b84821bc9afe7042853334cded88_icgraph" alt=""/></div>
<map name="astructShape_afc85b84821bc9afe7042853334cded88_icgraph" id="astructShape_afc85b84821bc9afe7042853334cded88_icgraph">
<area shape="rect" title="Returns true whether the input geometry is disjoint (no common points) with this geometry...." alt="" coords="431,46,539,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a04a43f69d18c9513f7b476197b2a95d3" title="Geometrically refines two objects for whether they are disjoint." alt="" coords="252,39,383,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#ad2a3e148599958aca40c3f3848ca75cc" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,204,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a8648ae83cd8bee000ca1b5bd0ae0eddf" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,180,112"/>
</map>
</div>

</div>
</div>
<a id="a2fbb9b9a688078ae99af4c289626df60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbb9b9a688078ae99af4c289626df60">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::equals </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry is spatially equal the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00929">929</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;                                                          {</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                <span class="keywordflow">return</span> arg.equals(otherArg);</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;        }, shape);</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a2fbb9b9a688078ae99af4c289626df60_icgraph.png" border="0" usemap="#astructShape_a2fbb9b9a688078ae99af4c289626df60_icgraph" alt=""/></div>
<map name="astructShape_a2fbb9b9a688078ae99af4c289626df60_icgraph" id="astructShape_a2fbb9b9a688078ae99af4c289626df60_icgraph">
<area shape="rect" title="Returns true whether the geometry is spatially equal the input geometry. False otherwise." alt="" coords="423,46,528,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a919f6dc96f5057a795445a5b679a8ae6" title="Returns true of the two objects are spatially equal." alt="" coords="252,5,375,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#addd437649b4408709d16ead7d714ea62" title="Geometrically refines two objects for spatial equality." alt="" coords="252,71,375,112"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#ad2a3e148599958aca40c3f3848ca75cc" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,37,204,79"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a8648ae83cd8bee000ca1b5bd0ae0eddf" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,103,180,144"/>
</map>
</div>

</div>
</div>
<a id="a0739ef5490685ef2c389e578fa26b361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0739ef5490685ef2c389e578fa26b361">&#9670;&nbsp;</a></span>inside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::inside </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry is completely inside (no inside-border common points) the input geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00868">868</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;                                                          {</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                <span class="keywordflow">return</span> arg.inside(otherArg);</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;        }, shape);</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a0739ef5490685ef2c389e578fa26b361_icgraph.png" border="0" usemap="#astructShape_a0739ef5490685ef2c389e578fa26b361_icgraph" alt=""/></div>
<map name="astructShape_a0739ef5490685ef2c389e578fa26b361_icgraph" id="astructShape_a0739ef5490685ef2c389e578fa26b361_icgraph">
<area shape="rect" title="Returns true whether the geometry is completely inside (no inside&#45;border common points) the input geo..." alt="" coords="423,46,524,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#addbc422783e4a80184b27532200c16b2" title="Geometrically refines two objects for &#39;R inside S&#39;." alt="" coords="252,39,375,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#ad2a3e148599958aca40c3f3848ca75cc" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,204,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a8648ae83cd8bee000ca1b5bd0ae0eddf" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,180,112"/>
</map>
</div>

</div>
</div>
<a id="a540f907bd548182b8b0ec4fcdd5e7b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540f907bd548182b8b0ec4fcdd5e7b50">&#9670;&nbsp;</a></span>intersects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::intersects </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the input geometry intersects (border or area) with this geometry. False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00844">844</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;                                                              {</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;                <span class="keywordflow">return</span> arg.intersects(otherArg);</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;        }, shape);</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a540f907bd548182b8b0ec4fcdd5e7b50_icgraph.png" border="0" usemap="#astructShape_a540f907bd548182b8b0ec4fcdd5e7b50_icgraph" alt=""/></div>
<map name="astructShape_a540f907bd548182b8b0ec4fcdd5e7b50_icgraph" id="astructShape_a540f907bd548182b8b0ec4fcdd5e7b50_icgraph">
<area shape="rect" title="Returns true whether the input geometry intersects (border or area) with this geometry...." alt="" coords="455,46,579,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a45401e61973c8226ee2b1fe1f375055c" title="Geometrically refines two objects for intersection." alt="" coords="252,39,407,80"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#ad2a3e148599958aca40c3f3848ca75cc" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="5,5,204,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a8648ae83cd8bee000ca1b5bd0ae0eddf" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="29,71,180,112"/>
</map>
</div>

</div>
</div>
<a id="a30ef5ee8dc975e9aa9e73723cc052b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ef5ee8dc975e9aa9e73723cc052b26">&#9670;&nbsp;</a></span>meets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherBoostGeometryObj &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Shape::meets </td>
          <td>(</td>
          <td class="paramtype">const OtherBoostGeometryObj &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true whether the geometry meets (touches) the input geometry (their insides do not have common points, but their borders do). False otherwise. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not all geometry type combinations are supported (see data type support). </dd></dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00917">917</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;                                                         {</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        <span class="keywordflow">return</span> std::visit([&amp;other](<span class="keyword">auto</span>&amp;&amp; arg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;            <span class="keywordflow">return</span> std::visit([&amp;arg](<span class="keyword">auto</span>&amp;&amp; otherArg) -&gt; <span class="keywordtype">bool</span> {</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;                <span class="keywordflow">return</span> arg.meets(otherArg);</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;            }, other.shape);</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;        }, shape);</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;    }</div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structShape_a30ef5ee8dc975e9aa9e73723cc052b26_icgraph.png" border="0" usemap="#astructShape_a30ef5ee8dc975e9aa9e73723cc052b26_icgraph" alt=""/></div>
<map name="astructShape_a30ef5ee8dc975e9aa9e73723cc052b26_icgraph" id="astructShape_a30ef5ee8dc975e9aa9e73723cc052b26_icgraph">
<area shape="rect" title="Returns true whether the geometry meets (touches) the input geometry (their insides do not have commo..." alt="" coords="437,46,540,73"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#aa8da2292354b906ad94b60cdbb091088" title="Returns true of the two objects meet (touch)." alt="" coords="267,5,389,47"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a8888ecdbd804e490a35234efcd98d5c7" title="Geometrically refines two objects for whether R and S meet (touch)." alt="" coords="267,71,389,112"/>
<area shape="rect" href="namespaceAPRIL_1_1uncompressed_1_1topology.html#ac274cf693c1c5168085295b575176ddb" title="Joins APRIL approximations for topological relations when two MBRs are equal." alt="" coords="5,5,219,47"/>
<area shape="rect" href="namespaceAPRIL_1_1standard.html#ad2a3e148599958aca40c3f3848ca75cc" title="Standard APRIL intermediate filter that filters two input objects. The join predicate is set in the g..." alt="" coords="13,71,211,112"/>
<area shape="rect" href="namespacerefinement_1_1relate.html#a8648ae83cd8bee000ca1b5bd0ae0eddf" title="Entrypoint function for when there is NO intermediate filter." alt="" coords="37,136,187,177"/>
</map>
</div>

</div>
</div>
<a id="a865387b93e9f027d4923a51ae7ffe9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865387b93e9f027d4923a51ae7ffe9cc">&#9670;&nbsp;</a></span>modifyBoostPointByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Shape::modifyBoostPointByIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies the point specified by 'index' with the new values x,y. (see derived method definitions) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position of the point to modify in the geometry object. </td></tr>
    <tr><td class="paramname">x</td><td>The new x value. </td></tr>
    <tr><td class="paramname">y</td><td>The new y value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00784">784</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;                                                                {</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;        std::visit([index, &amp;x, &amp;y](<span class="keyword">auto</span>&amp;&amp; arg) {</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;            arg.modifyBoostPointByIndex(index, x, y);</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;        }, shape);</div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae160e73c713890a7f23e91a133b30dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae160e73c713890a7f23e91a133b30dad">&#9670;&nbsp;</a></span>partitions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;size_t, TwoLayerClassE&gt; Shape::partitions</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The object's partition index, containing info about the partitions that this object intersects with and its two-layer index class in each of them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td><a class="el" href="structPartition.html" title="Holds all necessary partition information.">Partition</a> ID. </td></tr>
    <tr><td class="paramname">value</td><td>The two-layer index class of the object in that partition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="containers_8h_source.html#l00737">737</a> of file <a class="el" href="containers_8h_source.html">containers.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="containers_8h_source.html">containers.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
